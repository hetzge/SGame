package de.hetzge.sgame.map;

public enum TileOrientation {

	/**
	 * XXX XXX XXX
	 */
	FULL("XXXXXXXXX"),
	/**
	 * OOO OXO OOO
	 */
	CENTER("OOOOXOOOO"),
	/**
	 * OXO XXX OXO
	 */
	CROSS("OXOXXXOXO"),
	/**
	 * XXO XXO XXO
	 */
	HALF_LEFT("XXOXXOXXO"),
	/**
	 * OXX OXX OXX
	 */
	HALF_RIGHT("OXXOXXOXX"),
	/**
	 * XXX XXX OOO
	 */
	HALF_UP("XXXXXXOOO"),
	/**
	 * OOO XXX XXX
	 */
	HALF_DOWN("OOOXXXXXXXXX"),
	/**
	 * OXO XXX XXX
	 */
	HALF_DOWN_WAY_UP("OXOXXXXXX"),
	/**
	 * XXX XXX OXO
	 */
	HALF_UP_WAY_DOWN("XXXXXXOXO"),
	/**
	 * XXO XXX XXO
	 */
	HALF_LEFT_WAY_RIGHT("XXOXXXXXO"),
	/**
	 * OXX XXX OXX
	 */
	HALF_RIGHT_WA_LEFT("OXXXXXOXX"),
	/**
	 * OOO XOO XXO
	 */
	QUATER_LEFT_DOWN("OOOXOOXXO"),
	/**
	 * XXO XOO OOO
	 */
	QUATER_LEFT_UP("XXOXOOOOO"),
	/**
	 * OXX OOX OOO
	 */
	QUATER_RIGHT_UP("OXXOOXOOO"),
	/**
	 * OOO OOX OXX
	 */
	QUATER_RIGHT_DOWN("OOOOOXOXX"),
	/**
	 * OXO OXO OXO
	 */
	WAY_UP_DOWN("OXOOXOOXO"),
	/**
	 * OOO XXX OOO
	 */
	WAY_LEFT_RIGHT("OOOXXXOOO"),
	/**
	 * OXO XXO OOO
	 */
	WAY_LEFT_UP("OXOXXOOOO"),
	/**
	 * OOO XXO OXO
	 */
	WAY_LEFT_DOWN("OOOXXOOXO"),
	/**
	 * OXO OXX OOO
	 */
	WAY_RIGHT_UP("OXOOXXOOO"),
	/**
	 * OOO OXX OXO
	 */
	WAY_RIGHT_DOWN("OOOOXXOXO"),
	/**
	 * OOO XXO OOO
	 */
	WAY_LEFT_END("OOOXXOOOO"),
	/**
	 * OOO OXX OOO
	 */
	WAY_RIGHT_END("OOOOXXOOO"),
	/**
	 * OXO OXO OOO
	 */
	WAY_UP_END("OXOOXOOOO"),
	/**
	 * OOO OXO OXO
	 */
	WAY_DOWN_END("OOOOXOOXO"),
	/**
	 * OXX XXX XXX
	 */
	QUATER_LEFT_UP_OPPOSIT("OXXXXXXXX"),
	/**
	 * XXX XXX OXX
	 */
	QUATER_LEFT_DOWN_OPPOSIT("XXXXXXOXX"),
	/**
	 * XXO XXX XXX
	 */
	QUATER_RIGHT_UP_OPPOSIT("XXOXXXXXX"),
	/**
	 * XXX XXX XXO
	 */
	QUATER_RIGHT_DOWN_OPPOSIT("XXXXXXXXO");

	public static final char CHAR_1 = 'X';
	public static final char CHAR_2 = 'O';

	public static final Map<Orientation, Integer[]> EDGES = new HashMap<Orientation, Integer[]>() {
		{
			put(Orientation.UP, new Integer[] { 0, 1, 2 });
			put(Orientation.DOWN, new Integer[] { 6, 7, 8 });
			put(Orientation.LEFT, new Integer[] { 0, 3, 6 });
			put(Orientation.RIGHT, new Integer[] { 2, 5, 8 });
		}
	};

	public final String rules;

	private MapFieldType(String rules) {
		this.rules = rules;
	}

	public static List<MapFieldDescription> findPossibleTypes(MapFieldDescription up, MapFieldDescription down, MapFieldDescription left, MapFieldDescription right) {
		return findPossibleTypes(new HashMap<Orientation, MapFieldDescription>() {
			{
				put(Orientation.UP, up);
				put(Orientation.DOWN, down);
				put(Orientation.LEFT, left);
				put(Orientation.RIGHT, right);
			}
		});
	}

	private static List<MapFieldDescription> findPossibleTypes(Map<Orientation, MapFieldDescription> availableFields) {

		// all possible variants
		FastTable<MapFieldDescription> tileDescriptionVariants = MapFieldDescription.allPossibleVariants();

		// if every field around is null then return all
		if (availableFields.entrySet().stream().allMatch((Map.Entry<Orientation, MapFieldDescription> entry) -> {
			return entry.getValue() == null;
		})) {
			return tileDescriptionVariants;
		}

		// filter possible
		List<MapFieldDescription> result = tileDescriptionVariants.stream().filter((MapFieldDescription mapTileDescription) -> {
			return availableFields.entrySet().stream().filter((Map.Entry<Orientation, MapFieldDescription> entry) -> {
				return entry.getValue() != null;
			}).allMatch((Map.Entry<Orientation, MapFieldDescription> entry) -> {
				return matchTogether(entry, mapTileDescription.mapFieldType) && matchTogether(entry, mapTileDescription);
			});
		}).collect(Collectors.toList());

		if (result.isEmpty()) {
			System.out.println(Utils.mapFieldTypeAroundString(availableFields));
			return null;
		}
		return result;
	}

	public static boolean matchTogether(Map.Entry<Orientation, MapFieldDescription> matchWith, MapFieldType mapFieldType) {
		for (int i = 0; i <= 2; i++) {
			if (matchWith.getValue().mapFieldType.rules.toCharArray()[EDGES.get(Orientation.OPPOSIT.get(matchWith.getKey()))[i]] != mapFieldType.rules.toCharArray()[EDGES.get(matchWith.getKey())[i]]) {
				return false;
			}
		}
		return true;
	}

	public static boolean matchTogether(Map.Entry<Orientation, MapFieldDescription> matchWith, MapFieldDescription mapFieldDescription) {
		for (int i = 0; i <= 2; i++) {
			char c1 = matchWith.getValue().mapFieldType.rules.toCharArray()[EDGES.get(Orientation.OPPOSIT.get(matchWith.getKey()))[i]];
			if (c1 == MapFieldType.CHAR_1) {
				if (mapFieldDescription.groundFrom != matchWith.getValue().groundFrom) {
					return false;
				}
			} else if (c1 == MapFieldType.CHAR_2) {
				if (mapFieldDescription.groundTo != matchWith.getValue().groundTo) {
					return false;
				}
			}
		}
		return true;
	}
}
